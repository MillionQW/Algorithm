## 快速排序
快速排序的思想就是，选定一个pivot，第一轮后，我要让比pivot小的在pivot左边，比他他的要在他右边，然后两边去递归。   
虽然第一次我们找数组中间的那个值作为pivot，但是一次循环下来后，并不按pivot为临界点分割。
步骤：
1. 找数组中间的那个值为pivot（或者随机找，不考虑第一位的原因是如果是一个排序快完成的列表，性能会很差）；
2. 以 i 为左指针递增， j 为右指针递增；
3. 当 i 走到 array[i] 大于等于 pivot 时停下，（代码中是 ```while (array[i] > pivot) { i++ }``` 所以跳出 while 循环时 array[i] 就是那个大于等于 pivot 的数）；
4. 当 i 走到 array[i] 大于等于 pivot 时停下，（代码中是 ```while (array[j] < pivot) { j-- }``` 所以跳出 while 循环时 array[j] 就是那个小于等于 pivot 的数）；
5. i, j 确定后，看看 i 是不是还小于等于 j ，是就 ```swap(array, left, right)```；
6. 再走一个3, 4步骤，跳出 3, 4后，如果 i 已经大于等于 j 则不 swap，返回 i 现在的索引。
7. 以 i 的索引为分界，分割两个数组去递归；

## 堆排序
堆排序将数组当作二叉树来排序，基于以下前提：
- 索引0是树的根节点
- 除根节点外，其他节点的父节点都是```N/2```
- 节点L的左子节点是```2*L```
- 节点R的右子节点是```2*R+1```