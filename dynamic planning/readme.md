可以使用动态规划的情况有两个特征：
- 有最小边界；
- 有最优原子结构

把要求的最终问题转换为要解决他的子问题的子问题的子问题，抽出一个状态转移方程，得出最终问题的解。

如斐波那契数列
```
function fib(n) {
    if (n === 0) {
        return 0;
    }
    // 最小边界
    if (n === 1 || n === 2) {
        return 1;
    }
    // 最优原子结构
    return fib(n - 1) + fib(n - 2);
}
```

上面的方法容易理解，但是由于使用了递归，整个运算过程相当于一颗二叉树，且包含了很多重复计算的部分，算法复杂度为```O(n²)```

观察斐波那契数列可以发现除了前一项，后面其实是一个数列，可以利用自底向上叠加的方法得出最终的解。
```
function fib(n) {
    let sum = 0, a = 1, b = 1;
    if (n === 1 || n === 2) {
        return 1;
    }

    // 注意从3开始循环
    for (let i = 3; i <= n; i++) {
        sum = a + b;
        a = b;
        b = sum;
    }
    return sum;
    
}
```


### 剑指-面试题14 剪绳子
利用动态规划，已知长度为1，2，3时是特殊情况，因为最好的情况就是一刀都不剪的时候乘积最大。    
所以在找子最优解的时候，2的最优解是2，3的最优解是3（只是在绳子只有2和3时乘积是1和2，有点绕）
做动态规划题的规律就是从上往下分出子最优解，再从下往上求，比如长度为 n 的绳子，分为 n-i 和 i ，但求的时候从 1,2,3...往上求。而不是用递归，递归会出现重复计算。    

那么步骤就是：
1. 如果长度是1，2，3，直接得出最优解
```
if (length === 1) return 1;
if (length === 2) return 1;
if (length === 3) return 2;
```
2. 用一个数组把每个小于 n 的长度的最优解储存起来
```
let maxNums = [];
```
3. 找最优子解的时候0，1，2，3不剪
```
maxNums[0] = 0;
maxNums[1] = 1;
maxNums[2] = 2;
maxNums[3] = 3;
```   
4. 求出小于等于 n 的所有长度的最优解；
```
for (let i >=4; i <= length; i++) {
    let maxNums = [];
    let max = 0;
    for (let j = 1; j <=length / 2; j++) {
        res = maxNums[i][i - j];
        if (res > max) {
            max = res;
        }
    }
    maxNums[i] = max;
}
```  
动态规划解法的时间复杂度是O（n²），因为多了一步遍历求最优解。空间是 O（n）。

如果我们已经知道了把绳子 3段3段分成绩是最大的，那就可以用贪心算法。时间空间复杂度是O（1）   
在把大于3的数分解为最小单位的时候，最多剪到2或3时，乘积是最大的。**其他数必须剪，剪了的乘积一定大于或等于它本身（不信试试）**，那么到底2段2段分好还是3段3段分好？
由 ```n(n-3) > n(n-2)```得，3段3段分再好不过。   
（分的时候一定不要出现剩下1段的情况，那样最亏，不如拿出一个3，组成4，比如13，按3划分，会分成[3,3,3,3,1]，乘积是81，按[3,3,3,4]，乘积是108）。

```
// 贪心算法
function cutRope(length) {
    if (length === 0) return 0;
    if (length === 1) return 1;
    if (length === 2) return 2;
    if (length === 3) return 3;

    let timesOf3 = length / 3;

    length -= timesOf3 * 3;
    if (length === 1) {
        // 出现了多出一个1的情况
        --timesOf3;
        max = Math.pow(3, timesOf3) * 2 * 2; // 让出一个3，组成4
    } else if (length === 2) {
        max = Math.pow(3, timeOf3) * 2;
    } else {
        max = Math.pow(3, timeOf3);
    }
    return Max;
}
```
